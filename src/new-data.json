{
    "1063": [
        {
            "XPath": "/article[1]",
            "terms": "Algorithms for calculating variance\n 1063\n \n 238551525\n 2008-09-15T10:12:53Z\n \n Lese\n 206932\n \n \n \n Statistical algorithms\n Statistical deviation and dispersion\n Articles with example pseudocode\n \n \n \n \n \n Algorithms for calculating \n variance play a major role in \n statistical computing. A key problem in the design of good algorithms for this problem is that formulas for the variance may involve sums of squares, which can lead to \n numerical instability as well as to \n arithmetic overflow when dealing with large values.\n \n \n  I. Na\u00efve algorithm \n \n \n The \n formula for calculating the variance of an entire \n population of size n is:\n \n \n \n \n \\sigma^2 = \\displaystyle\\frac {\\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2/n}{n}. \\!\n \n \n The formula for calculating an \n unbiased estimate of the population variance from a finite \n sample of n observations is:\n \n \n \n \n s^2 = \\displaystyle\\frac {\\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2/n}{n-1}. \\!\n \n \n Therefore a naive algorithm to calculate the estimated variance is given by the following \n pseudocode: \n \n \n n = 0\n sum = 0\n sum_sqr = 0\n \n \n foreach x in data:\n n = n + 1\n sum = sum + x\n sum_sqr = sum_sqr + x*x\n end for\n \n \n mean = sum/n\n variance = (sum_sqr - sum*mean)/(n - 1)\n \n \n This algorithm can easily be adapted to compute the variance of a finite population: simply divide by n instead of n  minus; 1 on the last line.\n \n \n Because sum_sqr and sum * mean can be very similar numbers, the \n precision of the result can be much less than the inherent precision of the \n floating-point arithmetic used to perform the computation.  This is particularly bad if the variance is small relative to the sum of the numbers.\n \n \n \n \n  II. Two-pass algorithm \n \n \n An alternate approach, using a different formula for the variance, is given by the following pseudocode:\n \n \n n = 0\n sum1 = 0\n foreach x in data:\n n = n + 1\n sum1 = sum1 + x\n end for\n mean = sum1/n\n \n \n sum2 = 0\n foreach x in data:\n sum2 = sum2 + (x - mean)^2\n end for\n variance = sum2/(n - 1)\n \n \n This algorithm is often more numerically reliable than the na\u00efve \n algorithm I for large sets of data, although it can be worse if much of the data is very close to but not precisely equal to the mean and some are quite far away from it.\n \n \n The results of both of these simple algorithms (I and II) can depend inordinately on the ordering of the data and can give poor results for very large data sets due to repeated roundoff error in the accumulation of the sums. Techniques such as \n compensated summation can be used to combat this error to a degree.\n \n \n \n  IIa. Compensated variant \n \n \n The compensated-summation version of the algorithm above reads:\n \n \n n = 0\n sum1 = 0\n foreach x in data:\n n = n + 1\n sum1 = sum1 + x\n end for\n mean = sum1/n\n \n \n sum2 = 0\n sumc = 0\n foreach x in data:\n sum2 = sum2 + (x - mean)^2\n sumc = sumc + (x - mean)\n end for\n variance = (sum2 - sumc^2/n)/(n - 1)\n \n \n \n \n \n  III. On-line algorithm \n \n \n It is often useful to be able to compute the variance in a single pass, inspecting each value x_i only once; for example, when the data are being collected without enough storage to keep all the values, or when costs of memory access dominate those of computation.  For such an \n online algorithm, a \n recurrence relation is required between quantities from which the required statistics can be calculated in a numerically stable fashion.\n \n \n The following formulas can be used to update the \n mean and (estimated) variance of the sequence, for an additional element x_{\\mathrm{new}}. Here, m denotes the estimate of the population mean(using the sample mean), s2n-1 the estimate of the population variance, s2n the estimate of the sample variance, and n the number of elements in the sequence before the addition.\n \n \n \n \n m_{\\mathrm{new}} = \\frac{n \\; m_{\\mathrm{old}} + x_{\\mathrm{new}}}{n+1} = m_{\\mathrm{old}} + \\frac{x_{\\mathrm{new}} - m_{\\mathrm{old}}}{n+1} \\!\n \n \n \n \n s^2_{\\mathrm{n-1, new}} = \\frac{(n-1) \\; s^2_{\\mathrm{n-1, old}} + (x_{\\mathrm{new}} - m_{\\mathrm{new}}) \\, (x_{\\mathrm{new}} - m_{\\mathrm{old}})}{n} \\; \\; \\, \\,  \\; \\,     \\mathrm{n gt;0} \\!\n \n \n \n \n s^2_{\\mathrm{n, new}} = \\frac{n \\; s^2_{\\mathrm{n, old}} + (x_{\\mathrm{new}} - m_{\\mathrm{new}}) \\, (x_{\\mathrm{new}} - m_{\\mathrm{old}})}{n+1}.\n \n \n It turns out that a more suitable quantity for updating is the sum of squares of differences from the (current) mean, \\sum_{i=1}^n (x_i - m)^2, here denoted M_2:\n \n \n \n \n M_\\mathrm{2,new}\\! = M_\\mathrm{2,old} + (x_\\mathrm{new} - m_\\mathrm{old})(x_\\mathrm{new} - m_\\mathrm{new})\n \n :s^2_\\mathrm{n} = \\frac{M_2}{n}\n \n \n s^2_\\mathrm{n-1} = \\frac{M_2}{n-1}\n \n \n A numerically stable algorithm is given below.  It also computes the mean.\n This algorithm is due to Knuth,1\n who cites Welford.2\n \n \n n = 0\n mean = 0\n M2 = 0\n \n \n foreach x in data:\n n = n + 1\n delta = x - mean\n mean = mean + delta/n\n M2 = M2 + delta*(x - mean)      // This expression uses the new value of mean\n end for\n \n \n variance_n = M2/n\n variance = M2/(n - 1)\n \n \n This algorithm is much less prone to loss of precision due to massive cancellation, but might not be as efficient because of the division operation inside the loop.  For a particularly robust two-pass algorithm for computing the variance, first compute and subtract an estimate of the mean, and then use this algorithm on the residuals.\n \n \n A slightly more convenient form allows one to calculate the standard deviation without having to explicitly calculate the new mean. If n is the number of elements in the sequence after the addition of the new element, then one has\n \n \n s^2_{\\mathrm{n-1, new}} = \\frac{(n-2)s^2_{\\mathrm{n-1, old}}+\\frac{n-1}{n}\\left(x_\\text{new}-m_\\text{old}\\right)^2}{n-1}\n \n \n \n \n  IV. Weighted incremental algorithm \n \n \n When the observations are weighted, West (1979) 3 suggests this incremental algorithm:\n \n \n n = 0\n foreach x in the data:\n if n=0 then \n n = 1\n mean = x\n S = 0\n sumweight = weight\n else\n n = n + 1\n temp = weight + sumweight\n S = S + sumweight*weight*(x-mean)^2 / temp\n mean = mean + (x-mean)*weight / temp\n sumweight = temp\n end if\n end for\n Variance = S * n / ((n-1) * sumweight)  // if sample is the population, omit n/(n-1)\n \n \n \n \n  V. Parallel algorithm \n \n \n Chan et al.4 note that the above on-line algorithm III is a special case of an algorithm that works for any partition of the sample X into sets X^A, X^B:\n \n \n \\delta\\! = m^B - m^A\n \n :m^X = m^A + \\delta\\cdot\\frac{N^B}{N^X}\n \n \n M_2^X = M_2^A + M_2^B + \\delta^2\\cdot\\frac{N^A N^B}{N^X}.\n \n This may be useful when, for example, multiple processing units may be assigned to discrete parts of the input.\n \n \n \n  Higher-order statistics \n \n \n Terriberry5 extends Chan's formulae to calculating the third and fourth \n central moments, needed for example when estimating \n skewness and \n kurtosis:\n \n \n M_3^X = M_3^A + M_3^B + \\delta^3\\frac{N^A N^B (N^A - N^B)}{(N^X)^2} + 3\\delta\\frac{N^AM_2^B - N^BM_2^A}{N^X}\n \n :\\begin{align}\n M_4^X = M_4^A + M_4^B   + \\delta^4\\frac{N^A N^B \\left((N^A)^2 - N^A N^B + (N^B)^2\\right)}{(N^X)^3} \\\\\n                       + 6\\delta^2\\frac{(N^A)^2 M_2^B + (N^B)^2 M_2^A}{(N^X)^2} + 4\\delta\\frac{N^AM_3^B - N^BM_3^A}{N^X} \\\\\n \\end{align}\n \n \n Here the M_k are again the sums of powers of differences from the mean \\Sigma(x - \\overline{x})^k, giving\n \n \n skewness: g_1 = \\frac{\\sqrt{n} M_3}{M_2^{3/2}},\n \n :kurtosis: g_2 = \\frac{n M_4}{M_2^2}.\n \n \n For the incremental case (i.e., B = \\{x\\}), this simplifies to:\n \n \n \\delta\\! = x - m\n \n :m' = m + \\frac{\\delta}{n}\n \n \n M_2' = M_2 + \\delta^2 \\frac{ n-1}{n}\n \n :M_3' = M_3 + \\delta^3 \\frac{ (n - 1) (n - 2)}{n^2} - \\frac{3\\delta M_2}{n}\n \n \n M_4' = M_4 + \\frac{\\delta^4 (n - 1) (n^2 - 3n + 3)}{n^3} + \\frac{6\\delta^2 M_2}{n^2} - \\frac{4\\delta M_3}{n}\n \n \n It should be noted that by preserving the value \\delta / n, only one division operation is needed and thus that the higher-order statistics can be calculated for little incremental cost.\n \n \n \n \n \n  Example \n \n \n Assume that all floating point operations use the standard \n IEEE 754 double-precision arithmetic. Consider the sample (4, 7, 13, 16) from an infinite population. Based on this sample, the estimated population mean is 10, and the unbiased estimate of population variance is 30.  Both Algorithm I and Algorithm II compute these values correctly.  Next consider the sample (108 + 4, 108 + 7, 108 + 13, 108 + 16), which gives rise to the same estimated variance as the first sample.  Algorithm II computes this variance estimate correctly, but Algorithm I returns 29.333333333333332 instead of 30.  While this loss of precision may be tolerable and viewed as a minor flaw of Algorithm I, it is easy to find data that reveal a major flaw in the naive algorithm: Take the sample to be (109 + 4, 109 + 7, 109 + 13, 109 + 16).  Again the estimated population variance of 30 is computed correctly by Algorithm II, but the naive algorithm now computes it as  minus;170.66666666666666.  This is a serious problem with Algorithm I, since the variance can, by definition, never be negative.\n \n \n \n \n  See also \n \n \n \n \n \n \n Computational formula for the variance\n \n \n \n \n \n \n  References \n \n \n \n \n \n \n Donald E. Knuth (1998). \n \n \n \n \n \n \n The Art of Computer Programming\n \n \n \n \n \n , volume 2: Seminumerical Algorithms, 3rd edn., p. 232. Boston: Addison-Wesley.\n \n B. P. Welford (1962).\n \"Note on a method for calculating corrected sums of squares and products\". \n \n \n \n \n \n \n Technometrics\n \n \n \n \n \n  4(3):419\u2013420.\n \n D. H. D. West (1979). \n \n \n \n \n \n \n Communications of the ACM\n \n \n \n \n \n , 22, 9, 532-535: Updating Mean and Variance Estimates: An Improved Method''\n \n  Chan, Tony F.; \n Golub, Gene H.   LeVeque, Randall J. (1979), \n \"Updating Formulae and a Pairwise Algorithm for Computing Sample Variances.\", Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University .\n \n  Terriberry, Timothy B. (2007), \n Computing Higher-Order Moments Online,  \n \n \n \n \n \n \n  External links \n \n \n \n \n \n   \n \n \n \n \n \n \n \n \n \n \n \n \n Eric W. Weisstein\n \n \n \n \n \n \n \n \n \n \n \n , \n Sample Variance Computation at \n \n \n \n \n \n \n \n \n \n \n \n \n \n MathWorld\n \n \n \n \n \n \n \n \n \n \n \n \n ."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]",
            "terms": "I. Na\u00efve algorithm \n \n \n The \n formula for calculating the variance of an entire \n population of size n is:\n \n \n \n \n \\sigma^2 = \\displaystyle\\frac {\\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2/n}{n}. \\!\n \n \n The formula for calculating an \n unbiased estimate of the population variance from a finite \n sample of n observations is:\n \n \n \n \n s^2 = \\displaystyle\\frac {\\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2/n}{n-1}. \\!\n \n \n Therefore a naive algorithm to calculate the estimated variance is given by the following \n pseudocode: \n \n \n n = 0\n sum = 0\n sum_sqr = 0\n \n \n foreach x in data:\n n = n + 1\n sum = sum + x\n sum_sqr = sum_sqr + x*x\n end for\n \n \n mean = sum/n\n variance = (sum_sqr - sum*mean)/(n - 1)\n \n \n This algorithm can easily be adapted to compute the variance of a finite population: simply divide by n instead of n  minus; 1 on the last line.\n \n \n Because sum_sqr and sum * mean can be very similar numbers, the \n precision of the result can be much less than the inherent precision of the \n floating-point arithmetic used to perform the computation.  This is particularly bad if the variance is small relative to the sum of the numbers."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]",
            "terms": "II. Two-pass algorithm \n \n \n An alternate approach, using a different formula for the variance, is given by the following pseudocode:\n \n \n n = 0\n sum1 = 0\n foreach x in data:\n n = n + 1\n sum1 = sum1 + x\n end for\n mean = sum1/n\n \n \n sum2 = 0\n foreach x in data:\n sum2 = sum2 + (x - mean)^2\n end for\n variance = sum2/(n - 1)\n \n \n This algorithm is often more numerically reliable than the na\u00efve \n algorithm I for large sets of data, although it can be worse if much of the data is very close to but not precisely equal to the mean and some are quite far away from it.\n \n \n The results of both of these simple algorithms (I and II) can depend inordinately on the ordering of the data and can give poor results for very large data sets due to repeated roundoff error in the accumulation of the sums. Techniques such as \n compensated summation can be used to combat this error to a degree.\n \n \n \n  IIa. Compensated variant \n \n \n The compensated-summation version of the algorithm above reads:\n \n \n n = 0\n sum1 = 0\n foreach x in data:\n n = n + 1\n sum1 = sum1 + x\n end for\n mean = sum1/n\n \n \n sum2 = 0\n sumc = 0\n foreach x in data:\n sum2 = sum2 + (x - mean)^2\n sumc = sumc + (x - mean)\n end for\n variance = (sum2 - sumc^2/n)/(n - 1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]",
            "terms": "III. On-line algorithm \n \n \n It is often useful to be able to compute the variance in a single pass, inspecting each value x_i only once; for example, when the data are being collected without enough storage to keep all the values, or when costs of memory access dominate those of computation.  For such an \n online algorithm, a \n recurrence relation is required between quantities from which the required statistics can be calculated in a numerically stable fashion.\n \n \n The following formulas can be used to update the \n mean and (estimated) variance of the sequence, for an additional element x_{\\mathrm{new}}. Here, m denotes the estimate of the population mean(using the sample mean), s2n-1 the estimate of the population variance, s2n the estimate of the sample variance, and n the number of elements in the sequence before the addition.\n \n \n \n \n m_{\\mathrm{new}} = \\frac{n \\; m_{\\mathrm{old}} + x_{\\mathrm{new}}}{n+1} = m_{\\mathrm{old}} + \\frac{x_{\\mathrm{new}} - m_{\\mathrm{old}}}{n+1} \\!\n \n \n \n \n s^2_{\\mathrm{n-1, new}} = \\frac{(n-1) \\; s^2_{\\mathrm{n-1, old}} + (x_{\\mathrm{new}} - m_{\\mathrm{new}}) \\, (x_{\\mathrm{new}} - m_{\\mathrm{old}})}{n} \\; \\; \\, \\,  \\; \\,     \\mathrm{n gt;0} \\!\n \n \n \n \n s^2_{\\mathrm{n, new}} = \\frac{n \\; s^2_{\\mathrm{n, old}} + (x_{\\mathrm{new}} - m_{\\mathrm{new}}) \\, (x_{\\mathrm{new}} - m_{\\mathrm{old}})}{n+1}.\n \n \n It turns out that a more suitable quantity for updating is the sum of squares of differences from the (current) mean, \\sum_{i=1}^n (x_i - m)^2, here denoted M_2:\n \n \n \n \n M_\\mathrm{2,new}\\! = M_\\mathrm{2,old} + (x_\\mathrm{new} - m_\\mathrm{old})(x_\\mathrm{new} - m_\\mathrm{new})\n \n :s^2_\\mathrm{n} = \\frac{M_2}{n}\n \n \n s^2_\\mathrm{n-1} = \\frac{M_2}{n-1}\n \n \n A numerically stable algorithm is given below.  It also computes the mean.\n This algorithm is due to Knuth,1\n who cites Welford.2\n \n \n n = 0\n mean = 0\n M2 = 0\n \n \n foreach x in data:\n n = n + 1\n delta = x - mean\n mean = mean + delta/n\n M2 = M2 + delta*(x - mean)      // This expression uses the new value of mean\n end for\n \n \n variance_n = M2/n\n variance = M2/(n - 1)\n \n \n This algorithm is much less prone to loss of precision due to massive cancellation, but might not be as efficient because of the division operation inside the loop.  For a particularly robust two-pass algorithm for computing the variance, first compute and subtract an estimate of the mean, and then use this algorithm on the residuals.\n \n \n A slightly more convenient form allows one to calculate the standard deviation without having to explicitly calculate the new mean. If n is the number of elements in the sequence after the addition of the new element, then one has\n \n \n s^2_{\\mathrm{n-1, new}} = \\frac{(n-2)s^2_{\\mathrm{n-1, old}}+\\frac{n-1}{n}\\left(x_\\text{new}-m_\\text{old}\\right)^2}{n-1}"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[4]",
            "terms": "IV. Weighted incremental algorithm \n \n \n When the observations are weighted, West (1979) 3 suggests this incremental algorithm:\n \n \n n = 0\n foreach x in the data:\n if n=0 then \n n = 1\n mean = x\n S = 0\n sumweight = weight\n else\n n = n + 1\n temp = weight + sumweight\n S = S + sumweight*weight*(x-mean)^2 / temp\n mean = mean + (x-mean)*weight / temp\n sumweight = temp\n end if\n end for\n Variance = S * n / ((n-1) * sumweight)  // if sample is the population, omit n/(n-1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[5]",
            "terms": "V. Parallel algorithm \n \n \n Chan et al.4 note that the above on-line algorithm III is a special case of an algorithm that works for any partition of the sample X into sets X^A, X^B:\n \n \n \\delta\\! = m^B - m^A\n \n :m^X = m^A + \\delta\\cdot\\frac{N^B}{N^X}\n \n \n M_2^X = M_2^A + M_2^B + \\delta^2\\cdot\\frac{N^A N^B}{N^X}.\n \n This may be useful when, for example, multiple processing units may be assigned to discrete parts of the input.\n \n \n \n  Higher-order statistics \n \n \n Terriberry5 extends Chan's formulae to calculating the third and fourth \n central moments, needed for example when estimating \n skewness and \n kurtosis:\n \n \n M_3^X = M_3^A + M_3^B + \\delta^3\\frac{N^A N^B (N^A - N^B)}{(N^X)^2} + 3\\delta\\frac{N^AM_2^B - N^BM_2^A}{N^X}\n \n :\\begin{align}\n M_4^X = M_4^A + M_4^B   + \\delta^4\\frac{N^A N^B \\left((N^A)^2 - N^A N^B + (N^B)^2\\right)}{(N^X)^3} \\\\\n                       + 6\\delta^2\\frac{(N^A)^2 M_2^B + (N^B)^2 M_2^A}{(N^X)^2} + 4\\delta\\frac{N^AM_3^B - N^BM_3^A}{N^X} \\\\\n \\end{align}\n \n \n Here the M_k are again the sums of powers of differences from the mean \\Sigma(x - \\overline{x})^k, giving\n \n \n skewness: g_1 = \\frac{\\sqrt{n} M_3}{M_2^{3/2}},\n \n :kurtosis: g_2 = \\frac{n M_4}{M_2^2}.\n \n \n For the incremental case (i.e., B = \\{x\\}), this simplifies to:\n \n \n \\delta\\! = x - m\n \n :m' = m + \\frac{\\delta}{n}\n \n \n M_2' = M_2 + \\delta^2 \\frac{ n-1}{n}\n \n :M_3' = M_3 + \\delta^3 \\frac{ (n - 1) (n - 2)}{n^2} - \\frac{3\\delta M_2}{n}\n \n \n M_4' = M_4 + \\frac{\\delta^4 (n - 1) (n^2 - 3n + 3)}{n^3} + \\frac{6\\delta^2 M_2}{n^2} - \\frac{4\\delta M_3}{n}\n \n \n It should be noted that by preserving the value \\delta / n, only one division operation is needed and thus that the higher-order statistics can be calculated for little incremental cost."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[6]",
            "terms": "Example \n \n \n Assume that all floating point operations use the standard \n IEEE 754 double-precision arithmetic. Consider the sample (4, 7, 13, 16) from an infinite population. Based on this sample, the estimated population mean is 10, and the unbiased estimate of population variance is 30.  Both Algorithm I and Algorithm II compute these values correctly.  Next consider the sample (108 + 4, 108 + 7, 108 + 13, 108 + 16), which gives rise to the same estimated variance as the first sample.  Algorithm II computes this variance estimate correctly, but Algorithm I returns 29.333333333333332 instead of 30.  While this loss of precision may be tolerable and viewed as a minor flaw of Algorithm I, it is easy to find data that reveal a major flaw in the naive algorithm: Take the sample to be (109 + 4, 109 + 7, 109 + 13, 109 + 16).  Again the estimated population variance of 30 is computed correctly by Algorithm II, but the naive algorithm now computes it as  minus;170.66666666666666.  This is a serious problem with Algorithm I, since the variance can, by definition, never be negative."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[7]",
            "terms": "See also \n \n \n \n \n \n \n Computational formula for the variance"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[8]",
            "terms": "References \n \n \n \n \n \n \n Donald E. Knuth (1998). \n \n \n \n \n \n \n The Art of Computer Programming\n \n \n \n \n \n , volume 2: Seminumerical Algorithms, 3rd edn., p. 232. Boston: Addison-Wesley.\n \n B. P. Welford (1962).\n \"Note on a method for calculating corrected sums of squares and products\". \n \n \n \n \n \n \n Technometrics\n \n \n \n \n \n  4(3):419\u2013420.\n \n D. H. D. West (1979). \n \n \n \n \n \n \n Communications of the ACM\n \n \n \n \n \n , 22, 9, 532-535: Updating Mean and Variance Estimates: An Improved Method''\n \n  Chan, Tony F.; \n Golub, Gene H.   LeVeque, Randall J. (1979), \n \"Updating Formulae and a Pairwise Algorithm for Computing Sample Variances.\", Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University .\n \n  Terriberry, Timothy B. (2007), \n Computing Higher-Order Moments Online,"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[9]",
            "terms": "External links \n \n \n \n \n \n   \n \n \n \n \n \n \n \n \n \n \n \n \n Eric W. Weisstein\n \n \n \n \n \n \n \n \n \n \n \n , \n Sample Variance Computation at \n \n \n \n \n \n \n \n \n \n \n \n \n \n MathWorld\n \n \n \n \n \n \n \n \n \n \n \n \n ."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[1]",
            "terms": "The \n formula for calculating the variance of an entire \n population of size n is:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[2]",
            "terms": "\\sigma^2 = \\displaystyle\\frac {\\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2/n}{n}. \\!\n \n \n The formula for calculating an \n unbiased estimate of the population variance from a finite \n sample of n observations is:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[3]",
            "terms": "s^2 = \\displaystyle\\frac {\\sum_{i=1}^{n} x_i^2 - (\\sum_{i=1}^{n} x_i)^2/n}{n-1}. \\!\n \n \n Therefore a naive algorithm to calculate the estimated variance is given by the following \n pseudocode:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[4]",
            "terms": "n = 0\n sum = 0\n sum_sqr = 0"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[5]",
            "terms": "foreach x in data:\n n = n + 1\n sum = sum + x\n sum_sqr = sum_sqr + x*x\n end for"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[6]",
            "terms": "mean = sum/n\n variance = (sum_sqr - sum*mean)/(n - 1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[7]",
            "terms": "This algorithm can easily be adapted to compute the variance of a finite population: simply divide by n instead of n  minus; 1 on the last line."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[1]/p[8]",
            "terms": "Because sum_sqr and sum * mean can be very similar numbers, the \n precision of the result can be much less than the inherent precision of the \n floating-point arithmetic used to perform the computation.  This is particularly bad if the variance is small relative to the sum of the numbers."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/p[1]",
            "terms": "An alternate approach, using a different formula for the variance, is given by the following pseudocode:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/p[2]",
            "terms": "n = 0\n sum1 = 0\n foreach x in data:\n n = n + 1\n sum1 = sum1 + x\n end for\n mean = sum1/n"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/p[3]",
            "terms": "sum2 = 0\n foreach x in data:\n sum2 = sum2 + (x - mean)^2\n end for\n variance = sum2/(n - 1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/p[4]",
            "terms": "This algorithm is often more numerically reliable than the na\u00efve \n algorithm I for large sets of data, although it can be worse if much of the data is very close to but not precisely equal to the mean and some are quite far away from it."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/p[5]",
            "terms": "The results of both of these simple algorithms (I and II) can depend inordinately on the ordering of the data and can give poor results for very large data sets due to repeated roundoff error in the accumulation of the sums. Techniques such as \n compensated summation can be used to combat this error to a degree."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/ss1[1]/p[1]",
            "terms": "The compensated-summation version of the algorithm above reads:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/ss1[1]/p[2]",
            "terms": "n = 0\n sum1 = 0\n foreach x in data:\n n = n + 1\n sum1 = sum1 + x\n end for\n mean = sum1/n"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[2]/ss1[1]/p[3]",
            "terms": "sum2 = 0\n sumc = 0\n foreach x in data:\n sum2 = sum2 + (x - mean)^2\n sumc = sumc + (x - mean)\n end for\n variance = (sum2 - sumc^2/n)/(n - 1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[1]",
            "terms": "It is often useful to be able to compute the variance in a single pass, inspecting each value x_i only once; for example, when the data are being collected without enough storage to keep all the values, or when costs of memory access dominate those of computation.  For such an \n online algorithm, a \n recurrence relation is required between quantities from which the required statistics can be calculated in a numerically stable fashion."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[2]",
            "terms": "The following formulas can be used to update the \n mean and (estimated) variance of the sequence, for an additional element x_{\\mathrm{new}}. Here, m denotes the estimate of the population mean(using the sample mean), s2n-1 the estimate of the population variance, s2n the estimate of the sample variance, and n the number of elements in the sequence before the addition."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[3]",
            "terms": "m_{\\mathrm{new}} = \\frac{n \\; m_{\\mathrm{old}} + x_{\\mathrm{new}}}{n+1} = m_{\\mathrm{old}} + \\frac{x_{\\mathrm{new}} - m_{\\mathrm{old}}}{n+1} \\!\n \n \n \n \n s^2_{\\mathrm{n-1, new}} = \\frac{(n-1) \\; s^2_{\\mathrm{n-1, old}} + (x_{\\mathrm{new}} - m_{\\mathrm{new}}) \\, (x_{\\mathrm{new}} - m_{\\mathrm{old}})}{n} \\; \\; \\, \\,  \\; \\,     \\mathrm{n gt;0} \\!\n \n \n \n \n s^2_{\\mathrm{n, new}} = \\frac{n \\; s^2_{\\mathrm{n, old}} + (x_{\\mathrm{new}} - m_{\\mathrm{new}}) \\, (x_{\\mathrm{new}} - m_{\\mathrm{old}})}{n+1}.\n \n \n It turns out that a more suitable quantity for updating is the sum of squares of differences from the (current) mean, \\sum_{i=1}^n (x_i - m)^2, here denoted M_2:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[4]",
            "terms": "M_\\mathrm{2,new}\\! = M_\\mathrm{2,old} + (x_\\mathrm{new} - m_\\mathrm{old})(x_\\mathrm{new} - m_\\mathrm{new})\n \n :s^2_\\mathrm{n} = \\frac{M_2}{n}\n \n \n s^2_\\mathrm{n-1} = \\frac{M_2}{n-1}\n \n \n A numerically stable algorithm is given below.  It also computes the mean.\n This algorithm is due to Knuth,1\n who cites Welford.2"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[5]",
            "terms": "n = 0\n mean = 0\n M2 = 0"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[6]",
            "terms": "foreach x in data:\n n = n + 1\n delta = x - mean\n mean = mean + delta/n\n M2 = M2 + delta*(x - mean)      // This expression uses the new value of mean\n end for"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[7]",
            "terms": "variance_n = M2/n\n variance = M2/(n - 1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[8]",
            "terms": "This algorithm is much less prone to loss of precision due to massive cancellation, but might not be as efficient because of the division operation inside the loop.  For a particularly robust two-pass algorithm for computing the variance, first compute and subtract an estimate of the mean, and then use this algorithm on the residuals."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[9]",
            "terms": "A slightly more convenient form allows one to calculate the standard deviation without having to explicitly calculate the new mean. If n is the number of elements in the sequence after the addition of the new element, then one has"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[3]/p[10]",
            "terms": "s^2_{\\mathrm{n-1, new}} = \\frac{(n-2)s^2_{\\mathrm{n-1, old}}+\\frac{n-1}{n}\\left(x_\\text{new}-m_\\text{old}\\right)^2}{n-1}"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[4]/p[1]",
            "terms": "When the observations are weighted, West (1979) 3 suggests this incremental algorithm:"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[4]/p[2]",
            "terms": "n = 0\n foreach x in the data:\n if n=0 then \n n = 1\n mean = x\n S = 0\n sumweight = weight\n else\n n = n + 1\n temp = weight + sumweight\n S = S + sumweight*weight*(x-mean)^2 / temp\n mean = mean + (x-mean)*weight / temp\n sumweight = temp\n end if\n end for\n Variance = S * n / ((n-1) * sumweight)  // if sample is the population, omit n/(n-1)"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[5]/p[1]",
            "terms": "Chan et al.4 note that the above on-line algorithm III is a special case of an algorithm that works for any partition of the sample X into sets X^A, X^B:\n \n \n \\delta\\! = m^B - m^A\n \n :m^X = m^A + \\delta\\cdot\\frac{N^B}{N^X}\n \n \n M_2^X = M_2^A + M_2^B + \\delta^2\\cdot\\frac{N^A N^B}{N^X}.\n \n This may be useful when, for example, multiple processing units may be assigned to discrete parts of the input."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[5]/ss1[1]/p[1]",
            "terms": "Terriberry5 extends Chan's formulae to calculating the third and fourth \n central moments, needed for example when estimating \n skewness and \n kurtosis:\n \n \n M_3^X = M_3^A + M_3^B + \\delta^3\\frac{N^A N^B (N^A - N^B)}{(N^X)^2} + 3\\delta\\frac{N^AM_2^B - N^BM_2^A}{N^X}\n \n :\\begin{align}\n M_4^X = M_4^A + M_4^B   + \\delta^4\\frac{N^A N^B \\left((N^A)^2 - N^A N^B + (N^B)^2\\right)}{(N^X)^3} \\\\\n                       + 6\\delta^2\\frac{(N^A)^2 M_2^B + (N^B)^2 M_2^A}{(N^X)^2} + 4\\delta\\frac{N^AM_3^B - N^BM_3^A}{N^X} \\\\\n \\end{align}"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[5]/ss1[1]/p[2]",
            "terms": "Here the M_k are again the sums of powers of differences from the mean \\Sigma(x - \\overline{x})^k, giving\n \n \n skewness: g_1 = \\frac{\\sqrt{n} M_3}{M_2^{3/2}},\n \n :kurtosis: g_2 = \\frac{n M_4}{M_2^2}."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[5]/ss1[1]/p[3]",
            "terms": "For the incremental case (i.e., B = \\{x\\}), this simplifies to:\n \n \n \\delta\\! = x - m\n \n :m' = m + \\frac{\\delta}{n}\n \n \n M_2' = M_2 + \\delta^2 \\frac{ n-1}{n}\n \n :M_3' = M_3 + \\delta^3 \\frac{ (n - 1) (n - 2)}{n^2} - \\frac{3\\delta M_2}{n}\n \n \n M_4' = M_4 + \\frac{\\delta^4 (n - 1) (n^2 - 3n + 3)}{n^3} + \\frac{6\\delta^2 M_2}{n^2} - \\frac{4\\delta M_3}{n}\n \n \n It should be noted that by preserving the value \\delta / n, only one division operation is needed and thus that the higher-order statistics can be calculated for little incremental cost."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[6]/p[1]",
            "terms": "Assume that all floating point operations use the standard \n IEEE 754 double-precision arithmetic. Consider the sample (4, 7, 13, 16) from an infinite population. Based on this sample, the estimated population mean is 10, and the unbiased estimate of population variance is 30.  Both Algorithm I and Algorithm II compute these values correctly.  Next consider the sample (108 + 4, 108 + 7, 108 + 13, 108 + 16), which gives rise to the same estimated variance as the first sample.  Algorithm II computes this variance estimate correctly, but Algorithm I returns 29.333333333333332 instead of 30.  While this loss of precision may be tolerable and viewed as a minor flaw of Algorithm I, it is easy to find data that reveal a major flaw in the naive algorithm: Take the sample to be (109 + 4, 109 + 7, 109 + 13, 109 + 16).  Again the estimated population variance of 30 is computed correctly by Algorithm II, but the naive algorithm now computes it as  minus;170.66666666666666.  This is a serious problem with Algorithm I, since the variance can, by definition, never be negative."
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[7]/p[1]",
            "terms": "Computational formula for the variance"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[8]/p[1]",
            "terms": "Donald E. Knuth (1998). \n \n \n \n \n \n \n The Art of Computer Programming\n \n \n \n \n \n , volume 2: Seminumerical Algorithms, 3rd edn., p. 232. Boston: Addison-Wesley.\n \n B. P. Welford (1962).\n \"Note on a method for calculating corrected sums of squares and products\". \n \n \n \n \n \n \n Technometrics\n \n \n \n \n \n  4(3):419\u2013420.\n \n D. H. D. West (1979). \n \n \n \n \n \n \n Communications of the ACM\n \n \n \n \n \n , 22, 9, 532-535: Updating Mean and Variance Estimates: An Improved Method''\n \n  Chan, Tony F.; \n Golub, Gene H.   LeVeque, Randall J. (1979), \n \"Updating Formulae and a Pairwise Algorithm for Computing Sample Variances.\", Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University .\n \n  Terriberry, Timothy B. (2007), \n Computing Higher-Order Moments Online,"
        },
        {
            "XPath": "/article[1]/event[1]/rule[1]/act[1]/psychological_feature[1]/procedure[1]/activity[1]/algorithm[1]/bdy[1]/sec[9]/p[1]",
            "terms": "Eric W. Weisstein\n \n \n \n \n \n \n \n \n \n \n \n , \n Sample Variance Computation at \n \n \n \n \n \n \n \n \n \n \n \n \n \n MathWorld\n \n \n \n \n \n \n \n \n \n \n \n \n ."
        }
    ]
}